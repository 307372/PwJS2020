Raport III 1.06.2020

Poczyniłem postępy, wydaje mi się, że podstawowa wersja programu w zasadzie jest już ukończona i stabilna.
Porównam teraz stan z raportu drugiego ze stanem obecnym:

"Makra do myszy i klawiatury pisane z klawiatury" zamienione w "Makra do myszy i klawiatury składane w edytorze"
-Ta część programu już jak najbardziej w pełni działa. Wybór czynności, które dodałem jako domyślnie dostępne powinien
być wystarczający w większości przypadków, jednak jako że mam zamiar korzystać z tej aplikacji, prawdopodobnie przed
końcem projektu jeszcze kilka dodam.

"Autoclicker do przycisków na myszy i klawiaturze" zamienione w "Autoclicker do przycisków myszy i możliwość zrobienia
makra funkcjonalnie odpowiadającego autoclickerowi przycisku na klawiaturze"
-Te części programu również są w pełni sprawne. Makro działające jak autoclicker jest realizowalne w następującej formie:
W kreatorze wystarczy:
Dodać z zakładki "Logika" akcję "Wykonaj N razy" i ustawić ilość wykonań na absurdalnie dużą liczbę
Dodać z zakładki "Klawiatura" akcję "Kliknij klawisz" i ustawić potrzebny klawisz lub kombinację klawiszy.

Nazwać, zapisać, przejść do zakładki "makra", ustawić skrót klawiszowy i po jego naciśnięciu zacznie to lecieć.
Zatrzymanie odbywa się tym samym skrótem, co odtwarzanie, ew. w zakładce "Ustawienia" można sobie ustawić skrót awaryjny,
który zatrzymuje wszystkie odtwarzania w programie.

"Działanie programu w systemie Windows"
Działa bez zarzutu (przynajmniej u mnie), w folderze 'prototyp' znajduje się plik main.exe, uruchomienie go uruchomi program.
Program nadal na 99% nie będzie działał pod linuxem, bo jak już wspominałem, porzuciłem pracę nad kompatybilnością z tym
systemem, z powodu bibliotek 'mouse' i 'keyboard' i tego, że ich 'działanie' pod Linuxem to kiepski żart.

"Opcja 'nagrywania' makr zamiast pisania ich"
Od raportu drugiego sporo pozmieniałem od strony niewidzianej przez użytkownika (interfejs pozostał ten sam),
naprawiłem parę przeoczeń i ta część również działa, lub przynajmniej nie natrafiłem u siebie na błędy w działaniu.

"Prosty password manager"
Nie ruszyłem tego nadal i chyba nie ruszę, szlifowanie głównego programu już jest wystarczająco czasochłonne, a muszę
zdać też inne przedmioty. Na upartego można uznać, że jest to realizowane przez proste makra, jednak jest to rozwiązanie
znacznie mniej bezpieczne od po prostu wpisywania haseł z pamięci, więc nie mogę tego polecić.

Technologie:
UI: PySide2 (jak wspominałem poprzednio, zastąpił u mnie PyQt5)
Obsługa klawiatury: biblioteka keyboard (https://pypi.org/project/keyboard/)
Obsługa myszy: biblioteka mouse (https://pypi.org/project/mouse/)
Tworzenie pliku wykonywalnego: pyinstaller (https://pypi.org/project/PyInstaller/)

Skoro już odniosłem się do raportu drugiego, spróbuję w ogólnym kształcie opisać funkcje programu.
Po włączeniu, otwiera się główne okno, zawierające zakładki. Opiszę po kolei co jest gdzie i po co.

>karta 'Autoclicker'
W tej karcie znajdziemy interfejs graficzny pozwalający dostosować ustawienia autoclickera, takie jak:
-odstęp czasowy między kliknięciami od milisekund do godzin, można sobie wpisać jaki się chce.
-Wybór przycisku myszy, który ma być klikany przez autoclicker
-Skrót klawiszowy, którym się go uruchamia i zatrzymuje jego działanie
-Ilość kliknięć, lub odtwarzanie w nieskończoność, do wyboru
-Przyciski start i stop, może ktoś woli tak operować autoclickerem, dałem tą opcję, bo czemu nie.
Wszystkie właściwości autoclickera są automatycznie zapisywane do 'settings.dat' i wczytywane przed startem programu.
Layout elementów zostanie zmieniony, by dopasować go do rozmiaru karty.

>karta 'Ustawienia'
W tej karcie znajdziemy póki co raczej niewiele, ale mam kilka pomysłów co tu dorzucić.
-Skrót przerywający wszystkie odtwarzania - zatrzymuje (a przynajmniej powinien) absolutnie wszystkie odtwarzania, w tym
autoclicker, makra i podglądy nagrań lub makr. Przydatne, gdyby rzeczy wymknęły się z pod kontroli
-opcja autozapisu, domyślnie włączona, zapisuje automatycznie zmiany wszystkich skrótów klawiszowych (poza tymi
przypisanymi makrom, one są przypisane do pliku makra), jak również zapisuje zmiany ustawień autoclickera.
-'Zapisz' i 'Wczytaj' przydadzą się, jeśli ktoś nie chce korzystać z autozapisu.
-'Przywróć domyślne ustawienia' wczytuje ustawienia z pliku 'defaultSettings.dat'. Jeśli autozapis jest włączony,
to przy okazji nadpisze 'settings.dat'.

>karta 'Kreator'
Tu ma miejsce tworzenie makr. Odbywa się to przez dodanie czynności z 'czynności' (przez przycisk 'dodaj do makro', lub
podwójne kliknięcie w dany element) do 'listy komend tworzących makro'. Po dodaniu czynności, można edytować czynność
poprzez otworzenie jej w edytorze przez zaznaczenie czynności lub podwójne kliknięcie jej. Edytor, to okno pomocnicze
odtwierające się po prawej od głównego okna. Po wybraniu lub podwójnym kliknięciu czynności, można tam ustawić jej
parametry (o ile jest co zmieniać), po czym należy nacisnąć 'zapisz' w tym edytorze, co zaktualizuje czynność i jej opis.
Należy przy tym zaznaczyć, że wszystkie czynności mają wartości domyślne i lepiej nie zostawiać nic bez modyfikacji.
Po dodaniu których czynności się chce, należy nadać makru nazwę w polu 'nazwa makra' u dołu ekranu. Jeszcze nie dodałem
żadnych podpowiedzi do programu, ale w każdym razie nie da się zapisać makra bez nazwy, bo jego nazwa będzie potem nazwą
pliku. Z tego też powodu nie wszystkie znaki są dozwolone, ale o tym użytkownik nie jest (jeszcze) informowany, po prostu
makro się nie zapisuje.

Przyciskami testowymi proszę się nie przejmować, zostaną usunięte w finalnej wersji.

Skoro proces tworzenia makra już opisałem, to pora na szybki opis elementów interfejsu:
-'czynności' zawierają 3 zakładki z predefiniowanymi elementami, które można dodać do makra.
w 'Akcje myszki', znajdują się czynności jak ruch czy klikanie przycisków, w 'Akcje klawiatury' mamy wciskanie przycisków
na 3 różne sposoby, oraz 'Wypisz tekst', który 'wystukuje' tekst jakby był pisany z klawiatury, może się przydać w grach,
gdzie nie zawsze można wklejać dłuższe teksty do chatu. Testowane z tekstem na kilka tysięcy znaków i (u mnie) działa,
jest też 'Puść wszystkie klawisze', którego nazwa mówi sama za siebie. W zakładce "Logika" (nie miałem lepszego pomysłu
na nazwę), znajdziemy 3 sposoby czekania. Czekanie na akcję myszy i czekanie na akcję klawiatury mogą być potencjalnie
wieczne i ich długość jest zależna od tego kiedy użytkownik sobie wykona tą akcję, zatem oszacowanie czasu trwania makra
w prawej kolumnie 'listy komend' ich nie uwzględnia. Jest też 'Wykonaj N razy', czyli pętla for. N podajemy w edytorze.
W zakładce 'Nagrane', znajdziemy nagrane akcje myszy i klawiatury, które to nagrania użytkownik może tworzyć sam, po
kliknięciu 'Nowe nagranie' u dołu okna. Otwiera to edytor nagrań, gdzie możemy nagrać nagranie, nazwać je, przyciąć,
wyrzucić z nich konkretne rodzaje akcji po nagraniu. Wszystkie te czynności są odwracalne, więc można ciąć i wyrzucać
do woli. Gdy już nagranie będzie zadowalające, należy nacisnąć 'dodaj do czynności', a pojawi się ono w zakładce 'nagrane'.
Zostanie ono wtedy też automatycznie zapisane do pliku z nagraniami. Przycisk 'usuń nagranie' usuwa zaznaczone w zakładce
'nagrane' nagranie, oraz usuwa je z pliku. W tej chwili nie ma przed tym ostrzeżenia, ale je dodam. Po dodaniu nagrania
do listy komend tworzących makro, również można je modyfikować do woli. Dołączyłem kilka moich testowych nagrań, nic
ciekawego. Zakładka 'Makra' jeszcze nic nie zawiera, ale być może dodam opcje dodawania makr jako elementów makr.

-'Lista komend tworzących makro' to lista, do której dodajemy czynności z 'czynności'. Kolumna 'Nazwa czynności' zawiera,
po dodaniu elementu, jego nazwę, natomiast 'czas do wykonania' pokazuje czas, który upłynie od startu nagrania do momentu
odtworzenia elementu, którego nazwa jest w pierwszej kolumnie.
Przycisk 'usuń z makro' usuwa zaznaczoną akcję z 'listy komend', guziki ze strzałkami w górę i w dół pozwalają zmieniać
kolejność elementów w 'liście komend' wewnątrz danego poziomu 'listy komend'. Mówię na to lista, ale 'wykonaj N razy'
wymusza, żeby to było tak na prawdę drzewo. Przycisk 'odtwórz' odtwarza podgląd makra, można go przerwać awaryjnym
skrótem klawiszowym z zakładki 'ustawienia'. Przycisk 'wyczyść edytor' kasuje z 'listy komend' wszystkie dodane czynności.

>karta 'Makra', zawiera stworzone w kreatorze makra. Do prototypu dodałem proste makro otwierające painta pod winowsem.
Po zapisaniu makra, pojawi się ono tutaj, można zobaczyć jego czas trwania (przy prędkości = 1), należy nadać makru skrót
klawiszowy, aby można było go używać. Kolumna prędkość pozwala zmieniać prędkość odtwarzania makra. Checkbox na lewo od
nazwy makra póki co nic nie robi, jednak mam zamiar zrobić tak, że zaznaczając lub odznaczając go, można będzie włączyć
lub wyłączyć aktywację makra skrótem klawiszowym. Nie każdy zawsze chce mieć wszystkie swoje makra włączone.
Przycisk 'Usuń' usuwa makro, jeszcze bez okienka pytającego o potwierdzenie, ale mam zamiar to dodać. 'Dodaj nowe makro'
otwiera pustą zakładkę 'Kreator', gdzie możemy stworzyć sobie makro. Przycisk 'Edytuj' kopiuje i rozpakowuje makro do
kreatora, gdzie możemy je dowolnie modyfikować. Makro zostanie nadpisane jedynie, jeśli zapiszemy edytowane makro pod
tą samą nazwą (tutaj też dodam okienko z potwierdzeniem).
Przyciski 'inspect', 'save all macros', 'load all macros', 'clear macro data' to przyciski testowe, usunę je w wersji
finalnej.

To chyba wszystko, co ten program potrafi bazowo.

-Krytyczne spojrzenie na ten projekt
Wiele rzeczy nie jest zrobione idealnie w tym projekcie, jako mój pierwszy projekt o tym rozmiarze, to jestem pod
wrażeniem, że się w ogóle do czegoś nadaje, biorąc pod uwagę stan kodu.

Jest kompletnie nieczytelny. Główna klasa zawiera ~80 metod, nie mając zielonego pojęcia o sensownych schematach nazw,
dałem po prostu długie nazwy, które opisywały jakiej części programu dotyczy metoda, oraz co robi na tyle dokładnie,
żebym się w tym kompletnie nie pogubił, ale w konsekwencji około 60tej metody, zacząłem sobie pisać na kartce nazwy
metod, na których aktualnie pracuję. Tak się nie dało żyć, więc przeniosłem część metod do osobnych plików, dzieląc je
wg. części programu, której się tyczą, co znowu podobno nie jest zgodne z konwencją.

Wniosek - Muszę się pilnie dowiedzieć jak poprawie prowadzić projekt tego (i większego) rozmiaru.


Qt przy podłączaniu metod do elementów UI w .connect() przyjmuje metodę bez argumentów, więc na początku myślałem,
że doskonałym pomysłem będzie oparcie praktycznie wszystkich metod o self.'nazwa_zmiennej', zamiast normalnego
przekazywania argumentów do metody. Kilkadziesiąt metod później zdałem sobie sprawę, że nie mam zielonego pojęcia
która metoda operuje na jakich danych bez czytania całego kodu metody, co sprawiło, że debugowanie to była w późniejszych
etapach projektu, gdzie już sam nie pamiętałem co i jak która metoda robi, to była tortura, a że z Qt miałem pierwszą
styczność właśnie w ramach tego projektu, to takie problemy były na porządku dziennym.

Wniosek - Fajnie, że mogę używać 'self.' do przekazywania danych do metod, ale to okropny pomysł przy większym
projekcie.


Kiedy już miałem kilkadziesiąt metod, okazało się w pewnym momencie, że modyfikacja czegokolwiek, co zrobiłem wcześniej,
skutkuje koniecznością naprawiania masy błędów. Krótkowzroczność wstępnych implementacji niektórych fragmentów kodu
ograniczała moje możliwości tak bardzo, że np. musiałem przepisać wszystkie metody odnoszące się do nagrywania kilka
razy, zanim doszedłem do obecnej formy. Miało to miejsce z kilkoma rzeczami i zmarnowało mi absurdalne ilości czasu.

Wniosek - W następnym projekcie zaplanuję jakoś schemat przepływu danych na papierze, żeby uniknąć takich sytuacji.


Popełniłem jeszcze jeden błąd, chyba najgorszy, bo nie napisałem absolutnie żadnych testów, głównie dlatego, że nie
poszukałem jak to się robi. Przed tym projektem nie napisałem nic tak długiego, więc zaczynając nie sądziłem, że
zrobiłyby aż taką różnicę.

Wniosek - Muszę pisać testy, szczególnie pisząc w językach interpretowanych


Kolejnym błędem był wybór bibliotek na ten projekt, wybrałem Qt, bo to było pierwsze, co mi przyszło do głowy. Nie mam
pojęcia czy inne biblioteki do GUI nie byłyby lepsze do tego projektu, bo nawet nie szukałem pytań o to na stackoverflow.
Biblioteki keyboard i mouse wybrałem, bo wyskoczyły pierwsze po wyszukaniu 'python keyboard' i 'python mouse', a ich
funkcje wyglądały nieźle w opisie. Okazało się to być pułapką na niedoświadczonych. Przed tym projektem byłem
przekonany, że biblioteki pythonowe są w pełni sprawne, że mają informatywną dokumentację i że na 100% na stackoverflow
ktoś już miał ten sam problem, co ja i go rozwiązał. Za późno się zorientowałem, że nic z tego poprzedniego zdania nie
jest prawdą.

Wniosek - Powinienem wybierać biblioteki po zaczerpnięciu wcześniej informacji, a nie na ślepo, bo mogę się znowu
wpakować w pracę z bibliotekami, które trzeba poprawiać.


To chyba wszystko, jeśli o czymś nie wspomniałem lub napisałem ten raport kompletnie źle, to bardzo chętnie go poprawię.












